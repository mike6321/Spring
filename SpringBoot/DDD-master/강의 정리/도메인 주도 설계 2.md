## 도메인 주도 설계 2

**Respository는 하나의 Aggregate만 갖고 있는 것처럼 보여야 한다.**



**유비쿼터스 언어**

- 도메인에서 사용하는 용어를 코드에 반영하지 않으면 그 코드는 개발자에게 코드의 의미를 해석해야 하는 부담을 준다.
- 코드의 가독성을 높여서 코드를 분석하고 이해하는 시간을 절약한다.
- 용어가 정의 될 때마다 용어 사전에 이를 기록하고 명확하게 정의 함으로써 추후 또는 다른 사람들도 공통된 언어를 사용할 수 있도록 한다.
  - 즉, 모든 사람들이 봐야할 결과물이기 때문에 용어 사전이 필요한 것이다.
- Ex. 학생들을 crew라고 부를 시 객체 또한 Crew로 선언되어야 한다.

- 유비쿼터스 : 언제 어디서나 존재하는 신을 지칭하는 언어



**효과적인 모델링**

- 사용자와 개발자는 동일한 언어로 이야기하는가?



**BOUNDED CONTEXT**

- context의 경계 즉, 피자가 식당에 있나? 쓰레기통에 있나?에 따라 의미가 바뀌는 것
  - Ex. 피자가 식당에 접시 위에 있거나, 쓰레기통에 있는지에 따라 관심도가 달라진다.
- 같은 회원일 경우 어느 Context에 속하느냐에 따라 모델이 달라진다. 즉, 관심도가 달라지는 것이다.
  - Sales Context의 회원과 Support Context의 회원은 관심도가 달라지는 것이다.(행동이 달라진다.)
- context -> domain service -> aggregate -> entity 순으로 전략적 설계를 진행한다.



**좋은 BOUNDED CONTEXT**

- 하나의 팀에서 하나의 BOUNDED CONTEXT를 관리하는 것이 좋다.
- 최대 context 수는 aggregate 수와 동일하다.



**Context Map**

- context 간의 관계를 보여주는 것
- u : up stream
- d : down stream
- u에서 d로 데이터가 흘러간다는 뜻



**Context 설계**

- 객체 설계와 동일하게 양방향 보다는 단방향 설계가 좋다.
  - 양방향으로 할 시 한쪽의 수정이 영향을 받기 때문이다.
- 단방향으로 만드는 방식
  - API를 만들어서 API에 접근을 해서 데이터를 조회.



**프로젝트와 조직 관계**

- 주로 고객-공급자를 사용
  - 고객-공급자(Customer-Supplier Development) : 업스트림(서버:공급자), 다운스트림(클라이언트:고객)로 단방향으로 의존한다.



**DDD vs OOP**

- DDD는 OOP에 근간을 하지만 분리지어 존재
- DDD는 간접 참조를 활용
- 하나의 클래스를 두개 이상으로 만든다.
  - context 단위로 클래스를 나누어야 하기 때문이다.
  - 피자의 클래스가 두개 존재



**이벤트**

- 도메인 전문가도 인정할 수 있는 부분



