## 도메인 주도 설계

> 대상
>
> 스프링 웹 애플리케이션 개발자(1-2년차)
>
> 빠른 시간 내에 스프링 부트를 활용해 포폴을 완성하고 싶은 사람





**만들 것**

- 포멧 API를 이용하여 포켓몬 게임 만들기



**DDD 단점**

- DDD 기술 규칙과 패턴이 DDD 구현에 방해가 될 수 있다.
- CRUD 처럼 간단한 업무는 더 간단한 방법으로 구현하는 것이 옳다.



**기존의 개발**

- 데이터에 종속적인 애플리케이션
- DB 스키마가 정해지면 모든 코드가 정해지는 경우..
- 모델링과 개발과의 불일치가 발생 가능



**도메인 주도 설계**

- 기존의 개발에 대한 불일치를 해결하기 위한 노력 중 하나가 바로 DDD
- 도메인 모델의 적용 범위를 소스까지 녹여낸다.
- 설계와 구현이 함께 어우러져있는 이론 즉, 설계와 구축이 계속 반복되는 설계론이다.
- DDD를 잘해야한 다는 것은 전략적 설계를 잘해야한다는 것.



**도메인 모델**

- 특정 도메인을 개념적으로 표현한 것.
- 머릿 속에 있는 여러 그림을 소스로 녹아내는 것이 개발자가 할 일.



**비즈니스 로직 수행을 하는 곳은 어디인가?**

- 도메인 모델에서 수행



**도메인 주도 설계 기본 요소**

- 엔티티와 배류로 구분 되는데 도메인 기능도 제공되어야 한다. 즉, 상태뿐만 아니라 행동도 제공되어야 한다는 것이다.
- 도메인 모델을 객체지향적으로 구성하기 위해 상태 뿐만 아니라 행동도 가져야 한다.



**Value Object**

- Value Object는 불변 객체이다.
- 의미가 명확하거나 두 개 이상의 데이터가 개념적으로 하나인 경우 Value Object를 사용
  - 우편 번호의 경우를 Value Object로 사용되는 것이다.
  - 우편 번호라는 키워드들을 들었을 때, 모든 사람이 같은 개념을 생각한 것이 불변 객체



**가변 객체와 불변 객체**

*가변 객체*

~~~java
class Cash {
  private int dollars;

  public void mul(int factor) {
    this.dollars *= factor;
  }
}

Cash five = new Cash(5);
five.mul(10);
System.out.println(five);
~~~



*불변 객체*

~~~java
class Cash {
  private final int dollars;

  public Cash mul(int factor) {
    return new Cash(this.dollars * factor);
  }
}

Cash five = new Cash(5);
Cash fifty = five.mul(10);
System.out.println(fifty);
~~~

-  메모리가 낭비?
  - 메모리 낭비보다 



**도메인 모델에 set 메소드 넣지 않기**

- set과 change 메소드를 두었을 때 어떤 행동을 가지고 있는 명확하게 표현되는 것을 사용하는 것이 좋다.
- set을 넣지 않고 객체를 만들 때 객체의 핵심적인 상태들을 가진 채 생성을 해야하는 것이 좋다.
- 파라미터를 가진 생성자를 사용하는 것이 좋다.
  - 자동차를 생성할 때, 갖출 수 있는 모든 상태를 갖춘 후 생성을 하는 것이 좋다.
- 파라미터를 가진 생성자와 setter를 사용할 때 setter가 주는 의미를 확인하고 추가하는 것이 좋다.
  - setter와 change의 의미를!



**Anemic Domain Model**

- 빈약한 도메인 모델
- 객체지향의 오브젝트는 상태와 행위로 구성되어 있지만, 자바 엔터프라이즈 개발 방식은 단지 상태만 갖고 있다.
- getter/setter만으로 구성된 객체를 사용하게 되면 결국 Big Service Layer를 만들게 되는 것이다.



**Big Service Layer**

- 설계에 원칙이 맞지 않고 코드의 중복성과 오브젝트 재활용성을 극히 떨어뜨린다.



**Aggregate**

- 엔티티와 밸류 오브젝트를 한 곳에 묶어놓은 것
  - 동일한 라이프 사이클을 가진 것들 끼리 묶는다.
  - Ex. 자동차의 핸들과 타이어 같은 것들은 동일한 라이프 사이클을 가지고 있다.



**Aggregate Root**

- Aggregate를 만들 때 필수 객체들을 만들 수 있도록 컨트롤 한다.
- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.
- **애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.**
- **이는 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화할 수 있도록 돕는다.**
- 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.
- 루트 엔티티 선별
  - 외부에서 관찰하고 있는 엔티티가 바로 루트 엔티티(애그리거트 루트)
  - Ex. Buyer Aggregate에서 orderId를 바라보고(참조) 있다면, Order Aggregate의 Aggreagate root는 Order 엔티티가 된다.



**Aggregate 참조**

- 서로 다른 Aggregate의 참조 방식은 간접 참조를 사용한다.
  - 쉽게 분리도 가능하다는 것이다.(서로 다른 프로젝트로 관리가 가능하다. MSA)



**Repository**

- 테이블 단위가 아닌, Aggregate 단위로 가져오고 저장할 줄 알아야 한다.
- 완전한 Aggregate를 제공해야한다.
- DAO : 인프라(DB) 개념
- Repository : 객체 개념에 가까운 형식(collection 개념)
  - Collection에서 Aggreagate를 가져오거나 꺼내오는 개념



**여러 Aggregate가 필요한 기능**

- 결제 금액 계산 로직



**도메인 서비스**

- 비즈니스 로직 혹은 도메인 로직을 다루는 부분.
- 상태없이 로직만 가지고 있는 형태
- Aggregate 내부에 있거나 애플리케이션 서비스에 있을 수 있다.
- 도메인 서비스 선별 : 두개의 Aggregate를 사용하거나 위키나 jira에 관리될만한 녀석인가..?
  - 기획, 매니저도 해당 서비스에 대한 변경에 관심을 가지고 있는 경우는 도메인 서비스 측면이 된다.
- 도메인 서비스는 도메인 layer가 애플리케이션 layer로 침범하지 못하도록 막아주는 방파제 역할을 한다.
  - 애플리케이션 layer는 개발자에게만 관심을 가지는 영역..?



**모듈**

- 패키지

  - 계층 우선 vs 기능 우선
  - 계층 우선

  ~~~
  +-- application
  +-- domain
  +-- infra
  +-- ui
  ~~~

  - 기능 우선

  ~~~
  +-- item
  +-- pokemon
  +-- trainer
  ~~~



> 상태가 아니므로 @Component를 사용













